#   Рівень 3
#   Варіант 1
#   Зоомагазин займається продажем хом’ячкiв. Це мирнi домашнi iстоти, проте,
#   як виявилося, вони мають цiкаву харчову поведiнку. Для того,
#   щоб прогодувати хом’ячка, який живе наодинцi, потрiбно H пакетiв корму на день.
#   Однак, якщо кiлька хом’ячкiв живуть разом, у них прокидається жадiбнiсть.
#   У такому випадку кожен хом’ячок з’їдає додатково G пакетiв корму в день
#   за кожного сусiда. Денна норма H та жадiбнiсть G є iндивiдуальними
#   для кожного хом’ячка. Всього в магазинi є C хом’ячкiв. Ви бажаєте придбати
#   якомога бiльше, проте у вас є всього S пакетiв їжi на день.
#   Визначте максимальну кiлькiсть хом’ячкiв, яку ви можете прогодувати.
#
#   Реалізуйте функцію, яка поверне число - максимальне число хом'ячків.
#   Вхідні параметри функції: S — ваш денний запас їжi. 0 ≤ S ≤ 109
#   C — загальна кiлькiсть хом’ячкiв, яка є в продажу, 1 ≤ C ≤ 105
#   Матриця hamsters, яка містить С рядків, перший стовчик якої містить
#   денну норму корму, другий - рiвень жадiбностi кожного хом’ячка.
#   Денні норми є цілими додатніми числами і гарантовано меншими за 109.
#   Іноді у вас можуть бути не жадібні хом’ячки, але також можуть
#   траплятись і надзвичайно жадібні, рівень жадібності може бути як нульовим, так і великим цілим числом.
#
#   Приклад 1
#   S = 7 C = 3 hamsters = `[ [1 2], [2 2], [3 1]]``
#   Результат: 2
#   Пояснення: Можна взяти першого хом’ячка та будь-якого з iнших двох.
#
#   Приклад 2
#   S = 19 C = 4 hamsters = `[ [5 0], [2 2], [1 4], [5 1]]
#   Результат: 3
#   Пояснення: Третiй хом’ячок надто жадiбний. Можна взяти всiх iнших трьох,
#   тодi за день вони з’їдять (5 + 0 · 2) + (2 + 2 · 2) + (5 + 1 · 2) = 18 пакетiв
#
#   Приклад 3
#   S = 2 C = 2 hamsters = `[[1 50000], [1 60000]]
#   Результат: 1 Пояснення: Обидва хом’ячки надто жадiбнi, щоб їсти разом.
#
#   Для перевірки виконання роботи реалізованого алгоритму
#   слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище

import unittest


def how_many_hamsters(hamsters_list, hamsters_quantity, daily_food):
    hamsters_list = sorted(hamsters_list, key=lambda arr: arr[1])
    food_needed = 0
    hamsters_counter = 0
    _ = 0
    while food_needed < daily_food and _ < hamsters_quantity:
        food_needed += hamsters_list[_][0] + hamsters_list[_][1] * hamsters_quantity
        hamsters_counter += 1
        _ += 1
    return hamsters_counter


class Lab2Test(unittest.TestCase):
    def test_example1(self):
        S = 7
        C = 3
        hamsters = [
            [1, 2],
            [2, 2],
            [3, 1]
        ]
        expected_result = 2
        self.assertEqual(how_many_hamsters(hamsters, C, S), expected_result, "error!")

    def test_example2(self):
        S = 19
        C = 4
        hamsters = [
            [5, 0],
            [2, 2],
            [1, 4],
            [5, 1]
        ]
        expected_result = 3
        self.assertEqual(how_many_hamsters(hamsters, C, S), expected_result, "error!")

    def test_example3(self):
        S = 2
        C = 2
        hamsters = [
            [1, 50000],
            [1, 60000]
        ]
        expected_result = 1
        self.assertEqual(how_many_hamsters(hamsters, C, S), expected_result, "error!")


if __name__ == '__main__':
    unittest.main()
